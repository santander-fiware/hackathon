// Generated by CoffeeScript 1.4.0
var EventEmitter, Stream, each, split, thrift, transport,
  __slice = [].slice;

Stream = require('stream');

each = require('each');

thrift = require('thrift');

transport = require('thrift/lib/thrift/transport');

EventEmitter = require('events').EventEmitter;

split = module.exports.split = function(hqls) {
  var commented;
  if (Array.isArray(hqls)) {
    return hqls;
  }
  commented = false;
  hqls = hqls.split('\n').filter(function(line) {
    var skip;
    line = line.trim();
    skip = false;
    if (!commented && line.indexOf('/*') !== -1) {
      commented = '/*';
      skip = true;
    } else if (!commented && line === '--') {
      commented = '--';
      skip = true;
    } else if (commented === '/*' && line.lastIndexOf('*/') !== -1 && line.lastIndexOf('*/') === (line.length - 2)) {
      commented = false;
      skip = true;
    } else if (commented === '--' && line === '--') {
      commented = false;
      skip = true;
    }
    if (line.indexOf('--') === 0) {
      skip = true;
    }
    return !commented && !skip;
  }).join('\n');
  hqls = hqls.split(';');
  hqls = hqls.map(function(query) {
    return query.trim();
  });
  return hqls = hqls.filter(function(query) {
    return query.indexOf('--') !== 0 && query !== '';
  });
};

module.exports.createClient = function(options) {
  var client, connection, _ref, _ref1, _ref2, _ref3, _ref4;
  if (options == null) {
    options = {};
  }
  if ((_ref = options.version) == null) {
    options.version = '0.7.1-cdh3u3';
  }
  if ((_ref1 = options.server) == null) {
    options.server = '127.0.0.1';
  }
  if ((_ref2 = options.port) == null) {
    options.port = 10000;
  }
  if ((_ref3 = options.timeout) == null) {
    options.timeout = 1000;
  }
  if ((_ref4 = options.transport) == null) {
    options.transport = transport.TBufferedTransport;
  }
  connection = thrift.createConnection(options.server, options.port, options);
  client = thrift.createClient(require("./" + options.version + "/ThriftHive"), connection);
  return {
    connection: connection,
    client: client,
    end: connection.end.bind(connection),
    execute: function(query, callback) {
      var emitter;
      emitter = new EventEmitter;
      process.nextTick(function() {
        emitter.emit('before', query);
        return client.execute(query, function(err) {
          var emitError, lboth, lerror;
          if (err) {
            emitter.readable = false;
            lerror = emitter.listeners('error').length;
            lboth = emitter.listeners('both').length;
            emitError = lerror || (!lerror && !lboth && !callback);
            if (emitError) {
              emitter.emit('error', err);
            }
          } else {
            emitter.emit('end', null, query);
          }
          emitter.emit('both', err, query);
          if (callback) {
            return callback(err, callback);
          }
        });
      });
      return emitter;
    },
    query: function(query, size) {
      var buffer, callback, count, emitter, exec, fetch, handle,
        _this = this;
      if (arguments.length === 2 && typeof size === 'function') {
        callback = size;
        size = null;
      }
      exec = function() {
        emitter.emit('before', query);
        return client.execute(query, function(err) {
          var emitError, lboth, lerror;
          if (err) {
            emitter.readable = false;
            lerror = emitter.listeners('error').length;
            lboth = emitter.listeners('both').length;
            emitError = lerror || (!lerror && !lboth);
            if (emitError) {
              emitter.emit('error', err);
            }
            emitter.emit('both', err, query);
            return;
          }
          return fetch();
        });
      };
      if (query) {
        process.nextTick(exec);
      }
      buffer = [];
      count = 0;
      emitter = new Stream;
      emitter.size = size;
      emitter.readable = true;
      emitter.paused = 0;
      emitter.query = function(q) {
        if (query) {
          throw new Error('Query already defined');
        }
        query = q;
        exec();
        return this;
      };
      emitter.pause = function() {
        return this.paused = 1;
      };
      emitter.resume = function() {
        this.was = this.paused;
        this.paused = 0;
        if (this.was) {
          return fetch();
        }
      };
      handle = function(err, rows) {
        var emitError, lboth, lerror, row, _i, _len;
        if (err) {
          emitter.readable = false;
          lerror = emitter.listeners('error').length;
          lboth = emitter.listeners('both').length;
          emitError = lerror || (!lerror && !lboth);
          if (emitError) {
            emitter.emit('error', err);
          }
          emitter.emit('both', err, query);
          return;
        }
        rows = rows.map(function(row) {
          return row.split('\t');
        });
        for (_i = 0, _len = rows.length; _i < _len; _i++) {
          row = rows[_i];
          if (count === 0) {
            emitter.emit('row-first', row, 0);
          }
          emitter.emit('row', row, count++);
        }
        if (rows.length === emitter.size) {
          if (!emitter.paused) {
            return fetch();
          }
        } else {
          emitter.emit('row-last', row, count - 1);
          emitter.readable = false;
          emitter.emit('end', query);
          return emitter.emit('both', null, query);
        }
      };
      fetch = function() {
        if (emitter.paused || !emitter.readable) {
          return;
        }
        if (emitter.size) {
          return client.fetchN(emitter.size, handle);
        } else {
          return client.fetchAll(handle);
        }
      };
      return emitter;
    },
    multi_execute: function(hqls, callback) {
      var emitter,
        _this = this;
      emitter = new EventEmitter;
      hqls = split(hqls);
      each(hqls).on('item', function(next, query) {
        var exec;
        exec = _this.execute(query, next);
        return exec.on('before', function() {
          var _ref5;
          return (_ref5 = emitter.emit).call.apply(_ref5, [emitter, 'before'].concat(__slice.call(arguments)));
        });
      }).on('both', function(err) {
        var _ref5, _ref6, _ref7;
        if (err) {
          (_ref5 = emitter.emit).call.apply(_ref5, [emitter, 'error'].concat(__slice.call(arguments)));
        } else {
          (_ref6 = emitter.emit).call.apply(_ref6, [emitter, 'end'].concat(__slice.call(arguments)));
        }
        (_ref7 = emitter.emit).call.apply(_ref7, [emitter, 'both'].concat(__slice.call(arguments)));
        if (callback) {
          return callback(err);
        }
      });
      return emitter;
    },
    multi_query: function(hqls, size) {
      var query,
        _this = this;
      hqls = split(hqls);
      query = this.query();
      each(hqls).on('item', function(next, hql, i) {
        var exec;
        if (hqls.length !== i + 1) {
          exec = _this.execute(hql);
          exec.on('before', function() {
            var _ref5;
            return (_ref5 = query.emit).call.apply(_ref5, [query, 'before'].concat(__slice.call(arguments)));
          });
          exec.on('error', function(err) {
            var emitError, lboth, lerror;
            query.readable = false;
            lerror = query.listeners('error').length;
            lboth = query.listeners('both').length;
            emitError = lerror || (!lerror && !lboth);
            if (emitError) {
              query.emit('error', err);
            }
            return query.emit('both', err, query);
          });
          return exec.on('end', function() {
            return next();
          });
        } else {
          return query.query(hql, size);
        }
      });
      return query;
    }
  };
};
